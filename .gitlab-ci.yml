
variables:
  # Versions
  MENDER_REV: "master"
  META_MENDER_REV: "master"
  POKY_REV: "dunfell"
  MENDER_QA_REV: "master"
  MENDER_ARTIFACT_REV: "master"
  MENDER_CONDUCTOR_REV: "master"
  MENDER_CONDUCTOR_ENTERPRISE_REV: "master"
  DEPLOYMENTS_REV: "master"
  DEPLOYMENTS_ENTERPRISE_REV: "master"
  DEVICEAUTH_REV: "master"
  GUI_REV: "master"
  INVENTORY_REV: "master"
  INVENTORY_ENTERPRISE_REV: "master"
  USERADM_REV: "master"
  USERADM_ENTERPRISE_REV: "master"
  MENDER_API_GATEWAY_DOCKER_REV: "master"
  MENDER_CLI_REV: "master"
  INTEGRATION_REV: "master"
  TENANTADM_REV: "master"
  WORKFLOWS_REV: "master"
  WORKFLOWS_ENTERPRISE_REV: "master"
  CREATE_ARTIFACT_WORKER_REV: "master"
  MENDER_STRESS_TEST_CLIENT_REV: "master"
  META_OPENEMBEDDED_REV: "dunfell"
  META_RASPBERRYPI_REV: "dunfell"
  AUDITLOGS_REV: "master"
  MTLS_AMBASSADOR_REV: "master"
  DEVICECONNECT_REV: "master"
  MENDER_SHELL_REV: "master"

  # Build stage
  BUILD_CLIENT: "true"
  BUILD_SERVERS: "true"

  # Client test stage
  BUILD_QEMUX86_64_UEFI_GRUB: "true"
  TEST_QEMUX86_64_UEFI_GRUB: "true"
  BUILD_QEMUX86_64_BIOS_GRUB: "true"
  TEST_QEMUX86_64_BIOS_GRUB: "true"
  BUILD_QEMUX86_64_BIOS_GRUB_GPT: "true"
  TEST_QEMUX86_64_BIOS_GRUB_GPT: "true"
  BUILD_VEXPRESS_QEMU_UBOOT_UEFI_GRUB: "true"
  TEST_VEXPRESS_QEMU_UBOOT_UEFI_GRUB: "true"
  BUILD_VEXPRESS_QEMU: "true"
  TEST_VEXPRESS_QEMU: "true"
  BUILD_VEXPRESS_QEMU_FLASH: "true"
  TEST_VEXPRESS_QEMU_FLASH: "true"
  BUILD_BEAGLEBONEBLACK: "true"
  BUILD_RASPBERRYPI3: "false"
  BUILD_RASPBERRYPI4: "false"
  SPECIFIC_ACCEPTANCE_TEST: ""

  # Integration and backend integration tests
  RUN_INTEGRATION_TESTS: "true"
  SPECIFIC_INTEGRATION_TEST: ""
  TESTS_IN_PARALLEL: "4"

  # Publication
  PUBLISH_DOCKER_CLIENT_IMAGES: "false"
  PUBLISH_RELEASE_AUTOMATIC: "false"

  # Debugging options
  WAIT_IN_STAGE_INIT: ""
  WAIT_IN_STAGE_BUILD: ""
  WAIT_IN_STAGE_TEST: ""

  # Maintenance
  CLEAN_BUILD_CACHE: ""

  # Internal address for nfs sstate cache server (northamerica-northeast1-b)
  SSTATE_CACHE_INTRNL_ADDR: "10.162.0.2"

  # Global environment variables (not meant to be changed)
  DEBIAN_FRONTEND: noninteractive

  # Docker dind configuration.
  # To use dind, make sure gitlab-runner's configuration
  # has a common mount for /certs (i.e. runners.docker.volumes) directory
  # and that the dind service name is always docker (default hostname).
  DOCKER_HOST: "tcp://docker:2376"
  DOCKER_CERT_PATH: "/certs/client"
  DOCKER_TLS_VERIFY: "1"
  DOCKER_TLS_CERTDIR: "/certs"

include:
  - project: 'Northern.tech/Mender/mendertesting'
    file: '.gitlab-ci-check-commits-signoffs.yml'

stages:
  # .pre and .post have no effect and are only for documentation purposes. .pre
  # and .post stages run at the very start and very end of a pipeline,
  # regardless of where they are defined.
  - .pre
  - init
  - build
  - test
  - publish
  - release
  - .post

mender-qa:start:
  stage: .pre
  # Keep overhead low by using a small image with curl preinstalled.
  image: appropriate/curl
  before_script:
    - apk --update add jq
  script:
    - $CI_PROJECT_DIR/scripts/github_pull_request_status pending "mender-qa pipeline running" $CI_PIPELINE_URL ci/mender-qa

mender-qa:success:
  stage: .post
  when: on_success
  # Keep overhead low by using a small image with curl preinstalled.
  image: appropriate/curl
  before_script:
    - apk --update add jq
  script:
    - $CI_PROJECT_DIR/scripts/github_pull_request_status success "mender-qa pipeline passed" $CI_PIPELINE_URL ci/mender-qa

mender-qa:failure:
  stage: .post
  when: on_failure
  # Keep overhead low by using a small image with curl preinstalled.
  image: appropriate/curl
  before_script:
    - apk --update add jq
  script:
    - $CI_PROJECT_DIR/scripts/github_pull_request_status failure "mender-qa pipeline failed" $CI_PIPELINE_URL ci/mender-qa

init_workspace:
  stage: init
  image: alpine:3.12
  script:
    # Traps only work if executed in a sub shell.
    - "("

    # Default value, will later be overwritten if successful
    - echo "failure" > /JOB_RESULT.txt

    - function handle_exit() {
      ${CI_PROJECT_DIR}/scripts/maybe-wait-in-stage.sh WAIT_IN_STAGE_INIT ${CI_PROJECT_DIR}/WAIT_IN_STAGE_INIT;
      };
      trap handle_exit EXIT

    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - apk --update add git openssh bash python3 curl py3-pip jq
    - pip3 install --upgrade pyyaml

    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status pending "Gitlab ${CI_JOB_NAME} started" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

    # Prepare SSH keys
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add - > /dev/null
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan github.com >> ~/.ssh/known_hosts

    # Bash function to checkout repos
    # The last parameter is optional. When omitted, master is checked out. This allow building
    # old integration release branches which don't have all current repos in component-maps.yml
    - |
      function checkout_repo() {
        if [ $# -lt 3 ]; then
          echo "Usage: checkout_repo repo_id clone_url clone_path [clone_rev]"
          return 1
        fi

        repo_id=$1
        clone_url=$2
        clone_path=$3
        clone_rev=${4:-master}

        git clone $clone_url $clone_path || return 1

        (
          cd $clone_path &&
          git fetch -u -f origin ${clone_rev}:pr &&
          git checkout pr ||
          git checkout -f -b pr ${clone_rev}
        ) || return 1

        (
          cd $clone_path
          echo "# $(git log -n1 --oneline)" >> ${CI_PROJECT_DIR}/build_revisions.env
          echo "export ${repo_id}_REV=$clone_rev" >> ${CI_PROJECT_DIR}/build_revisions.env
          echo "export ${repo_id}_REV_GIT_SHA=$(git rev-parse HEAD)" >> ${CI_PROJECT_DIR}/build_revisions.env
        ) || return 1
      }

    # Clean WORKSPACE and clone poky in the root
    - find ${WORKSPACE}
      -mindepth 1
      -maxdepth 1
      -not -name $(basename ${CI_PROJECT_DIR})
      -exec rm -rf '{}' ';'
    - cd ${WORKSPACE}
    - git init . && git remote add origin https://github.com/mendersoftware/poky
    - git fetch && git checkout -f origin/${POKY_REV}
    - (
    -   echo "# $(git log -n1 --oneline)" >> ${CI_PROJECT_DIR}/build_revisions.env
    -   echo "export POKY_REV=$POKY_REV" >> ${CI_PROJECT_DIR}/build_revisions.env
    -   echo "export POKY_REV_GIT_SHA=$(git rev-parse HEAD)" >> ${CI_PROJECT_DIR}/build_revisions.env
    - )

    # Add MENDER_QA_REV, which is special, since it is this repository.
    - if echo "$CI_BUILD_REF_NAME" | egrep '^pr_[0-9]+$'; then
        export MENDER_QA_REV="pull/$(echo "$CI_BUILD_REF_NAME" | egrep -o '[0-9]+')/head";
      else
        export MENDER_QA_REV="$CI_BUILD_REF_NAME";
      fi
    - (
    -   cd mender-qa
    -   echo "# $(git log -n1 --oneline)" >> ${CI_PROJECT_DIR}/build_revisions.env
    -   echo "export MENDER_QA_REV=$MENDER_QA_REV" >> ${CI_PROJECT_DIR}/build_revisions.env
    -   echo "export MENDER_QA_REV_GIT_SHA=$(git rev-parse HEAD)" >> ${CI_PROJECT_DIR}/build_revisions.env
    - )

    # Add other repositories.
    - checkout_repo INTEGRATION https://github.com/mendersoftware/integration integration $INTEGRATION_REV
    - checkout_repo META_MENDER https://github.com/mendersoftware/meta-mender meta-mender $META_MENDER_REV
    - checkout_repo MENDER https://github.com/mendersoftware/mender go/src/github.com/mendersoftware/mender $MENDER_REV
    - checkout_repo DEPLOYMENTS https://github.com/mendersoftware/deployments go/src/github.com/mendersoftware/deployments $DEPLOYMENTS_REV
    - checkout_repo DEPLOYMENTS_ENTERPRISE git@github.com:mendersoftware/deployments-enterprise go/src/github.com/mendersoftware/deployments-enterprise $DEPLOYMENTS_ENTERPRISE_REV
    - checkout_repo DEVICEAUTH https://github.com/mendersoftware/deviceauth go/src/github.com/mendersoftware/deviceauth $DEVICEAUTH_REV
    - checkout_repo GUI https://github.com/mendersoftware/gui gui $GUI_REV
    - checkout_repo INVENTORY https://github.com/mendersoftware/inventory go/src/github.com/mendersoftware/inventory $INVENTORY_REV
    - checkout_repo INVENTORY_ENTERPRISE git@github.com:mendersoftware/inventory-enterprise.git go/src/github.com/mendersoftware/inventory-enterprise $INVENTORY_ENTERPRISE_REV
    - checkout_repo USERADM https://github.com/mendersoftware/useradm go/src/github.com/mendersoftware/useradm $USERADM_REV
    - checkout_repo USERADM_ENTERPRISE git@github.com:mendersoftware/useradm-enterprise go/src/github.com/mendersoftware/useradm-enterprise $USERADM_ENTERPRISE_REV
    - checkout_repo MENDER_API_GATEWAY_DOCKER https://github.com/mendersoftware/mender-api-gateway-docker mender-api-gateway-docker $MENDER_API_GATEWAY_DOCKER_REV
    - checkout_repo MENDER_STRESS_TEST_CLIENT https://github.com/mendersoftware/mender-stress-test-client go/src/github.com/mendersoftware/mender-stress-test-client $MENDER_STRESS_TEST_CLIENT_REV
    - checkout_repo MENDER_ARTIFACT https://github.com/mendersoftware/mender-artifact go/src/github.com/mendersoftware/mender-artifact $MENDER_ARTIFACT_REV
    - checkout_repo TENANTADM git@github.com:mendersoftware/tenantadm go/src/github.com/mendersoftware/tenantadm $TENANTADM_REV
    - checkout_repo WORKFLOWS git@github.com:mendersoftware/workflows go/src/github.com/mendersoftware/workflows $WORKFLOWS_REV
    - checkout_repo WORKFLOWS_ENTERPRISE git@github.com:mendersoftware/workflows-enterprise go/src/github.com/mendersoftware/workflows-enterprise $WORKFLOWS_ENTERPRISE_REV
    - checkout_repo CREATE_ARTIFACT_WORKER git@github.com:mendersoftware/create-artifact-worker go/src/github.com/mendersoftware/create-artifact-worker $CREATE_ARTIFACT_WORKER_REV
    - checkout_repo META_OPENEMBEDDED git://git.openembedded.org/meta-openembedded.git meta-openembedded $META_OPENEMBEDDED_REV
    - checkout_repo META_RASPBERRYPI git://github.com/agherzan/meta-raspberrypi.git meta-raspberrypi $META_RASPBERRYPI_REV
    - checkout_repo MENDER_CONDUCTOR git://github.com/mendersoftware/mender-conductor.git go/src/github.com/mendersoftware/mender-conductor $MENDER_CONDUCTOR_REV
    - checkout_repo MENDER_CONDUCTOR_ENTERPRISE git@github.com:mendersoftware/mender-conductor-enterprise.git go/src/github.com/mendersoftware/mender-conductor-enterprise $MENDER_CONDUCTOR_ENTERPRISE_REV
    - checkout_repo MENDER_CLI https://github.com/mendersoftware/mender-cli.git go/src/github.com/mendersoftware/mender-cli $MENDER_CLI_REV
    - checkout_repo AUDITLOGS git@github.com:mendersoftware/auditlogs go/src/github.com/mendersoftware/auditlogs $AUDITLOGS_REV
    - checkout_repo MTLS_AMBASSADOR git@github.com:mendersoftware/mtls-ambassador go/src/github.com/mendersoftware/mtls-ambassador $MTLS_AMBASSADOR_REV
    - checkout_repo DEVICECONNECT https://github.com/mendersoftware/deviceconnect go/src/github.com/mendersoftware/deviceconnect $DEVICECONNECT_REV
    - checkout_repo MENDER_SHELL https://github.com/mendersoftware/mender-shell go/src/github.com/mendersoftware/mender-shell $MENDER_SHELL_REV

    # Print for debug purposes
    - cat ${CI_PROJECT_DIR}/build_revisions.env

    # Save artifact the rest of the pipeline
    - tar -czf /tmp/workspace.tar.gz .
    - mv /tmp/workspace.tar.gz ${CI_PROJECT_DIR}/workspace.tar.gz

    # Always keep this at the end of the script stage
    - echo "success" > /JOB_RESULT.txt

    - ")"

  after_script:
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

  artifacts:
    expire_in: 2w
    paths:
      - workspace.tar.gz
      - build_revisions.env

.template_build_test_acc: &build_and_test_acceptance
  image: mendersoftware/mender-test-containers:mender-client-acceptance-testing
  needs:
    - init_workspace
  tags:
    - mender-qa-slave-highcpu
  before_script:
    # collect cpu, load avg, memory and io usage every 2 secs forever
    # use 'sar' from sysstat to render the result file manually
    - service sysstat start && sar -P ALL 2 -o /var/log/sysstat/sysstat.log -uqrbS >/dev/null 2>&1 &
    # Default value, will later be overwritten if successful
    - echo "failure" > /JOB_RESULT.txt
    # Export required yocto-build script variables
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - chown -R mender:mender ${WORKSPACE}
    # This template is used in both build and acc test stages,
    # for build stage, force default configuration QEMUX86_64_UEFI_GRUB
    - test -n "$ONLY_BUILD" && export BUILD_QEMUX86_64_UEFI_GRUB=true
    - test -n "$ONLY_BUILD" && export TEST_QEMUX86_64_UEFI_GRUB=false
    # Post job status
    - source ${CI_PROJECT_DIR}/build_revisions.env
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status pending "Gitlab ${CI_JOB_NAME} started" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"
    # Enable nesting VMs
    - modprobe -r kvm_intel && modprobe kvm_intel nested=Y
    # Enable NFS cache for yocto
    - mount.nfs4 ${SSTATE_CACHE_INTRNL_ADDR}:/sstate-cache /mnt/sstate-cache
  script:
    # Traps only work if executed in a sub shell.
    - "("
    - mv workspace.tar.gz /tmp
    - rm -rf ${WORKSPACE}
    - mkdir -p ${WORKSPACE}
    - cd ${WORKSPACE}
    - tar -xf /tmp/workspace.tar.gz

    - function handle_exit() {
      if test -n "$ONLY_BUILD"; then
      ${CI_PROJECT_DIR}/scripts/maybe-wait-in-stage.sh WAIT_IN_STAGE_BUILD ${CI_PROJECT_DIR}/WAIT_IN_STAGE_BUILD;
      else
      ${CI_PROJECT_DIR}/scripts/maybe-wait-in-stage.sh WAIT_IN_STAGE_TEST ${CI_PROJECT_DIR}/WAIT_IN_STAGE_TEST;
      fi;
      };
      trap handle_exit EXIT

    - source ${CI_PROJECT_DIR}/build_revisions.env
    - chown -R mender:mender ${WORKSPACE}
    - export HOME="/home/mender"
    - sudo -E -u mender ${WORKSPACE}/mender-qa/scripts/yocto-build-and-test.sh

    - if [ -d $WORKSPACE/meta-mender/tests/acceptance/coverage ]; then
        mkdir -p ${CI_PROJECT_DIR}/acceptance-tests-coverage;
        cp -r $WORKSPACE/meta-mender/tests/acceptance/coverage/* ${CI_PROJECT_DIR}/acceptance-tests-coverage;
      fi

    # Always keep this at the end of the script stage
    - echo "success" > /JOB_RESULT.txt

    - ")"

build_client:
  only:
    variables:
      - $BUILD_CLIENT == "true"
      - $RUN_INTEGRATION_TESTS == "true"
  stage: build
  <<: *build_and_test_acceptance
  services:
    - docker:19.03-dind
  variables:
    JOB_BASE_NAME: mender_qemux86_64_uefi_grub
    ONLY_BUILD: "true"
  after_script:
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - if [ "$(cat /JOB_RESULT.txt)" != "success" ]; then ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"; fi

    - mkdir -p stage-artifacts
    - docker save mendersoftware/mender-client-qemu:pr -o stage-artifacts/mender-client-qemu.tar
    - docker save mendersoftware/mender-client-qemu-rofs:pr -o stage-artifacts/mender-client-qemu-rofs.tar
    - cp /var/log/sysstat/sysstat.log .
    - sadf sysstat.log -g -- -qurbS > sysstat.svg

    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

  artifacts:
    expire_in: 2w
    paths:
      - stage-artifacts/
      - sysstat.log
      - sysstat.svg

build_servers:
  stage: build
  only:
    variables:
      - $BUILD_SERVERS == "true"
      - $RUN_INTEGRATION_TESTS == "true"
  needs:
    - init_workspace
  image: docker
  services:
    - docker:19.03-dind
  tags:
    - mender-qa-slave-highcpu
  before_script:
    # Default value, will later be overwritten if successful
    - echo "failure" > /JOB_RESULT.txt
    # Dependencies
    - apk --update add bash git make python3 py-pip
    - pip3 install pyyaml
    # Post job status
    - source ${CI_PROJECT_DIR}/build_revisions.env
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status pending "Gitlab ${CI_JOB_NAME} started" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"
    # Prepare workspace
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - mv workspace.tar.gz /tmp
    - rm -rf ${WORKSPACE}
    - mkdir -p ${WORKSPACE}
    - cd ${WORKSPACE}
    - tar -xf /tmp/workspace.tar.gz
  script:
    - ${WORKSPACE}/mender-qa/scripts/servers-build.sh
  after_script:
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - if [ "$(cat /JOB_RESULT.txt)" != "success" ]; then ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"; fi

    - mkdir -p stage-artifacts
    - for repo in `${CI_PROJECT_DIR}/../integration/extra/release_tool.py -l docker`; do
        if ! echo $repo | grep -q mender-client-qemu; then
          docker_url=$(${CI_PROJECT_DIR}/../integration/extra/release_tool.py --map-name docker $repo docker_url);
          docker save $docker_url:pr -o stage-artifacts/${repo}.tar;
        fi;
      done

    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

  artifacts:
    expire_in: 2w
    paths:
      - stage-artifacts/

test_accep_qemux86_64_uefi_grub:
  only:
    # Even though the build for this configuration is done unconditionally in build_client job,
    # we will still trigger this one for BUILD_QEMUX86_64_UEFI_GRUB to be able to collect artifacts
    variables:
      - $BUILD_QEMUX86_64_UEFI_GRUB == "true"
      - $TEST_QEMUX86_64_UEFI_GRUB == "true"
  stage: test
  <<: *build_and_test_acceptance
  variables:
    JOB_BASE_NAME: mender_qemux86_64_uefi_grub
  after_script:
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - if [ "$(cat /JOB_RESULT.txt)" != "success" ]; then ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"; fi

    - if [ "$TEST_QEMUX86_64_UEFI_GRUB" = "true" ]; then
        cp $WORKSPACE/meta-mender/tests/acceptance/results.xml results_accep_qemux86_64_uefi_grub.xml;
        cp $WORKSPACE/meta-mender/tests/acceptance/report.html report_accep_qemux86_64_uefi_grub.html;
      fi

    - if [ "$NIGHTLY_BUILD" = "true" ]; then
    -   ${CI_PROJECT_DIR}/scripts/mantra_post_test_results 1 nightly-$(date +%Y-%m-%d) results_accep_qemux86_64_uefi_grub.xml
    - fi

    - mkdir -p stage-artifacts
    - cp $WORKSPACE/qemux86-64-uefi-grub/qemux86-64-uefi-grub_release_1_*.mender stage-artifacts/
    - cp /var/log/sysstat/sysstat.log .
    - sadf sysstat.log -g -- -qurbS > sysstat.svg

    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

  artifacts:
    expire_in: 2w
    when: always
    paths:
      - stage-artifacts/
      - results_accep_qemux86_64_uefi_grub.xml
      - report_accep_qemux86_64_uefi_grub.html
      - acceptance-tests-coverage
      - sysstat.log
      - sysstat.svg
    reports:
      junit: results_accep_qemux86_64_uefi_grub.xml

test_accep_vexpress_qemu:
  only:
    variables:
      - $BUILD_VEXPRESS_QEMU == "true"
      - $TEST_VEXPRESS_QEMU == "true"
  stage: test
  <<: *build_and_test_acceptance
  variables:
    JOB_BASE_NAME: mender_vexpress_qemu
  after_script:
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - if [ "$(cat /JOB_RESULT.txt)" != "success" ]; then ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"; fi

    - if [ "$TEST_VEXPRESS_QEMU" = "true" ]; then
        cp $WORKSPACE/meta-mender/tests/acceptance/results.xml results_accep_vexpress_qemu.xml;
        cp $WORKSPACE/meta-mender/tests/acceptance/report.html report_accep_vexpress_qemu.html;
      fi

    - if [ "$NIGHTLY_BUILD" = "true" ]; then
    -   ${CI_PROJECT_DIR}/scripts/mantra_post_test_results 2 nightly-$(date +%Y-%m-%d) results_accep_vexpress_qemu.xml
    - fi

    - mkdir -p stage-artifacts
    - cp $WORKSPACE/vexpress-qemu/vexpress-qemu_release_1_*.mender stage-artifacts/
    - cp /var/log/sysstat/sysstat.log .
    - sadf sysstat.log -g -- -qurbS > sysstat.svg

    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

  artifacts:
    expire_in: 2w
    when: always
    paths:
      - stage-artifacts/
      - results_accep_vexpress_qemu.xml
      - report_accep_vexpress_qemu.html
      - acceptance-tests-coverage
      - sysstat.log
      - sysstat.svg
    reports:
      junit: results_accep_vexpress_qemu.xml

test_accep_qemux86_64_bios_grub:
  only:
    variables:
      - $BUILD_QEMUX86_64_BIOS_GRUB == "true"
      - $TEST_QEMUX86_64_BIOS_GRUB == "true"
  stage: test
  <<: *build_and_test_acceptance
  variables:
    JOB_BASE_NAME: mender_qemux86_64_bios_grub
  after_script:
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - if [ "$(cat /JOB_RESULT.txt)" != "success" ]; then ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"; fi

    - if [ "$TEST_QEMUX86_64_BIOS_GRUB" = "true" ]; then
        cp $WORKSPACE/meta-mender/tests/acceptance/results.xml results_accep_qemux86_64_bios_grub.xml;
        cp $WORKSPACE/meta-mender/tests/acceptance/report.html report_accep_qemux86_64_bios_grub.html;
      fi

    - if [ "$NIGHTLY_BUILD" = "true" ]; then
    -   ${CI_PROJECT_DIR}/scripts/mantra_post_test_results 3 nightly-$(date +%Y-%m-%d) results_accep_qemux86_64_bios_grub.xml
    - fi

    - mkdir -p stage-artifacts
    - cp $WORKSPACE/qemux86-64-bios-grub/qemux86-64-bios-grub_release_1_*.mender stage-artifacts/
    - cp /var/log/sysstat/sysstat.log .
    - sadf sysstat.log -g -- -qurbS > sysstat.svg

    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

  artifacts:
    expire_in: 2w
    when: always
    paths:
      - stage-artifacts/
      - results_accep_qemux86_64_bios_grub.xml
      - report_accep_qemux86_64_bios_grub.html
      - acceptance-tests-coverage
      - sysstat.log
      - sysstat.svg
    reports:
      junit: results_accep_qemux86_64_bios_grub.xml

test_accep_qemux86_64_bios_grub_gpt:
  only:
    variables:
      - $BUILD_QEMUX86_64_BIOS_GRUB_GPT == "true"
      - $TEST_QEMUX86_64_BIOS_GRUB_GPT == "true"
  stage: test
  <<: *build_and_test_acceptance
  variables:
    JOB_BASE_NAME: mender_qemux86_64_bios_grub_gpt
  after_script:
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - if [ "$(cat /JOB_RESULT.txt)" != "success" ]; then ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"; fi

    - if [ "$TEST_QEMUX86_64_BIOS_GRUB_GPT" = "true" ]; then
        cp $WORKSPACE/meta-mender/tests/acceptance/results.xml results_accep_qemux86_64_bios_grub_gpt.xml;
        cp $WORKSPACE/meta-mender/tests/acceptance/report.html report_accep_qemux86_64_bios_grub_gpt.html;
      fi

    - if [ "$NIGHTLY_BUILD" = "true" ]; then
    -   ${CI_PROJECT_DIR}/scripts/mantra_post_test_results 4 nightly-$(date +%Y-%m-%d) results_accep_qemux86_64_bios_grub_gpt.xml
    - fi

    - mkdir -p stage-artifacts
    - cp $WORKSPACE/qemux86-64-bios-grub-gpt/qemux86-64-bios-grub-gpt_release_1_*.mender stage-artifacts/
    - cp /var/log/sysstat/sysstat.log .
    - sadf sysstat.log -g -- -qurbS > sysstat.svg

    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

  artifacts:
    expire_in: 2w
    when: always
    paths:
      - stage-artifacts/
      - results_accep_qemux86_64_bios_grub_gpt.xml
      - report_accep_qemux86_64_bios_grub_gpt.html
      - acceptance-tests-coverage
      - sysstat.log
      - sysstat.svg
    reports:
      junit: results_accep_qemux86_64_bios_grub_gpt.xml

test_accep_vexpress_qemu_uboot_uefi_grub:
  only:
    variables:
      - $BUILD_VEXPRESS_QEMU_UBOOT_UEFI_GRUB == "true"
      - $TEST_VEXPRESS_QEMU_UBOOT_UEFI_GRUB == "true"
  stage: test
  <<: *build_and_test_acceptance
  variables:
    JOB_BASE_NAME: mender_vexpress_qemu_uboot_uefi_grub
  after_script:
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - if [ "$(cat /JOB_RESULT.txt)" != "success" ]; then ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"; fi

    - if [ "$TEST_VEXPRESS_QEMU_UBOOT_UEFI_GRUB" = "true" ]; then
        cp $WORKSPACE/meta-mender/tests/acceptance/results.xml results_accep_vexpress_qemu_uboot_uefi_grub.xml;
        cp $WORKSPACE/meta-mender/tests/acceptance/report.html report_accep_vexpress_qemu_uboot_uefi_grub.html;
      fi

    - if [ "$NIGHTLY_BUILD" = "true" ]; then
    -   ${CI_PROJECT_DIR}/scripts/mantra_post_test_results 5 nightly-$(date +%Y-%m-%d) results_accep_vexpress_qemu_uboot_uefi_grub.xml
    - fi

    - mkdir -p stage-artifacts
    - cp $WORKSPACE/vexpress-qemu-uboot-uefi-grub/vexpress-qemu-uboot-uefi-grub_release_1_*.mender stage-artifacts/
    - cp /var/log/sysstat/sysstat.log .
    - sadf sysstat.log -g -- -qurbS > sysstat.svg

    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

  artifacts:
    expire_in: 2w
    when: always
    paths:
      - stage-artifacts/
      - results_accep_vexpress_qemu_uboot_uefi_grub.xml
      - report_accep_vexpress_qemu_uboot_uefi_grub.html
      - acceptance-tests-coverage
      - sysstat.log
      - sysstat.svg
    reports:
      junit: results_accep_vexpress_qemu_uboot_uefi_grub.xml

# Note that vexpress-qemu-flash configuration does not generate a ext4 image so
# the build script does not generate the Mender Artifact neither.
# This job collects the .ubifs for debugging but not for release publishing
test_accep_vexpress_qemu_flash:
  only:
    variables:
      - $BUILD_VEXPRESS_QEMU_FLASH == "true"
      - $TEST_VEXPRESS_QEMU_FLASH == "true"
  stage: test
  <<: *build_and_test_acceptance
  variables:
    JOB_BASE_NAME: mender_vexpress_qemu_flash
  after_script:
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - if [ "$(cat /JOB_RESULT.txt)" != "success" ]; then ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"; fi

    - if [ "$TEST_VEXPRESS_QEMU_FLASH" = "true" ]; then
        cp $WORKSPACE/meta-mender/tests/acceptance/results.xml results_accep_vexpress_qemu_flash.xml;
        cp $WORKSPACE/meta-mender/tests/acceptance/report.html report_accep_vexpress_qemu_flash.html;
      fi

    - if [ "$NIGHTLY_BUILD" = "true" ]; then
    -   ${CI_PROJECT_DIR}/scripts/mantra_post_test_results 6 nightly-$(date +%Y-%m-%d) results_accep_vexpress_qemu_flash.xml
    - fi

    - mkdir -p stage-artifacts
    - cp $WORKSPACE/vexpress-qemu-flash/core-image-minimal-vexpress-qemu-flash.ubifs stage-artifacts/
    - cp /var/log/sysstat/sysstat.log .
    - sadf sysstat.log -g -- -qurbS > sysstat.svg

    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

  artifacts:
    expire_in: 2w
    when: always
    paths:
      - stage-artifacts/
      - results_accep_vexpress_qemu_flash.xml
      - report_accep_vexpress_qemu_flash.html
      - acceptance-tests-coverage
      - sysstat.log
      - sysstat.svg
    reports:
      junit: results_accep_vexpress_qemu_flash.xml

test_accep_beagleboneblack:
  only:
    variables:
      - $BUILD_BEAGLEBONEBLACK == "true"
      - $TEST_BEAGLEBONEBLACK == "true"
  stage: test
  <<: *build_and_test_acceptance
  variables:
    JOB_BASE_NAME: mender_beagleboneblack
  after_script:
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - if [ "$(cat /JOB_RESULT.txt)" != "success" ]; then ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"; fi

    - if [ "$TEST_BEAGLEBONEBLACK" = "true" ]; then
        cp $WORKSPACE/meta-mender/tests/acceptance/results.xml results_accep_beagleboneblack.xml;
        cp $WORKSPACE/meta-mender/tests/acceptance/report.html report_accep_beagleboneblack.html;
      fi
    - mkdir -p stage-artifacts
    - cp $WORKSPACE/beagleboneblack/beagleboneblack_release_1_*.mender stage-artifacts/
    - cp $WORKSPACE/beagleboneblack/mender-beagleboneblack_*.sdimg.gz stage-artifacts/
    - cp /var/log/sysstat/sysstat.log .
    - sadf sysstat.log -g -- -qurbS > sysstat.svg

    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

  artifacts:
    expire_in: 2w
    when: always
    paths:
      - stage-artifacts/
      - results_accep_beagleboneblack.xml
      - report_accep_beagleboneblack.html
      - acceptance-tests-coverage
      - sysstat.log
      - sysstat.svg
    reports:
      junit: results_accep_beagleboneblack.xml

test_accep_raspberrypi3:
  only:
    variables:
      - $BUILD_RASPBERRYPI3 == "true"
      - $TEST_RASPBERRYPI3 == "true"
  stage: test
  <<: *build_and_test_acceptance
  variables:
    JOB_BASE_NAME: mender_raspberrypi3
  after_script:
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - if [ "$(cat /JOB_RESULT.txt)" != "success" ]; then ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"; fi

    - if [ "$TEST_RASPBERRYPI3" = "true" ]; then
        cp $WORKSPACE/meta-mender/tests/acceptance/results.xml results_accep_raspberrypi3.xml;
        cp $WORKSPACE/meta-mender/tests/acceptance/report.html report_accep_raspberrypi3.html;
      fi
    - mkdir -p stage-artifacts
    - cp $WORKSPACE/raspberrypi3/raspberrypi3_release_1_*.mender stage-artifacts/
    - cp $WORKSPACE/raspberrypi3/mender-raspberrypi3_*.sdimg.gz stage-artifacts/
    - cp /var/log/sysstat/sysstat.log .
    - sadf sysstat.log -g -- -qurbS > sysstat.svg

    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

  artifacts:
    expire_in: 2w
    when: always
    paths:
      - stage-artifacts/
      - results_accep_raspberrypi3.xml
      - report_accep_raspberrypi3.html
      - acceptance-tests-coverage
      - sysstat.log
      - sysstat.svg
    reports:
      junit: results_accep_raspberrypi3.xml

test_accep_raspberrypi4:
  only:
    variables:
      - $BUILD_RASPBERRYPI4 == "true"
      - $TEST_RASPBERRYPI4 == "true"
  stage: test
  <<: *build_and_test_acceptance
  variables:
    JOB_BASE_NAME: mender_raspberrypi4
  after_script:
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - if [ "$(cat /JOB_RESULT.txt)" != "success" ]; then ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"; fi

    - if [ "$TEST_RASPBERRYPI4" = "true" ]; then
        cp $WORKSPACE/meta-mender/tests/acceptance/results.xml results_accep_raspberrypi4.xml;
        cp $WORKSPACE/meta-mender/tests/acceptance/report.html report_accep_raspberrypi4.html;
      fi
    - mkdir -p stage-artifacts
    - cp $WORKSPACE/raspberrypi4/raspberrypi4_release_1_*.mender stage-artifacts/
    - cp $WORKSPACE/raspberrypi4/mender-raspberrypi4_*.sdimg.gz stage-artifacts/
    - cp /var/log/sysstat/sysstat.log .
    - sadf sysstat.log -g -- -qurbS > sysstat.svg

    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

  artifacts:
    expire_in: 2w
    when: always
    paths:
      - stage-artifacts/
      - results_accep_raspberrypi4.xml
      - report_accep_raspberrypi4.html
      - acceptance-tests-coverage
      - sysstat.log
      - sysstat.svg
    reports:
      junit: results_accep_raspberrypi4.xml

test_backend_integration_enterprise:
  only:
    variables:
      - $RUN_INTEGRATION_TESTS == "true"
  stage: test
  image: docker/compose:alpine-1.27.4
  variables:
    TEST_SUITE: "enterprise"
  services:
    - docker:19.03-dind
  tags:
    - mender-qa-slave-highcpu
  needs:
    - init_workspace
    - build_servers
    - build_mender-artifact
  before_script:
    # Default value, will later be overwritten if successful
    - echo "failure" > /JOB_RESULT.txt

    - docker version
    - apk --update add bash git py-pip gcc make python2-dev
      libc-dev libffi-dev openssl-dev python3 curl jq sysstat
    - pip3 install pyyaml
    # Restore workspace from init stage
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - mv workspace.tar.gz build_revisions.env stage-artifacts /tmp
    - rm -rf ${WORKSPACE}
    - mkdir -p ${WORKSPACE}
    - cd ${WORKSPACE}
    - tar -xf /tmp/workspace.tar.gz
    - mv /tmp/build_revisions.env /tmp/stage-artifacts .

    # Load all docker images except client
    - for repo in `integration/extra/release_tool.py -l docker`; do
        if ! echo $repo | grep -q mender-client-qemu; then
          docker load -i stage-artifacts/${repo}.tar;
        fi;
      done
    # Login for private repos
    - docker login -u menderbuildsystem -p ${DOCKER_HUB_PASSWORD}
    - docker login -u ntadm_menderci -p ${REGISTRY_MENDER_IO_PASSWORD} registry.mender.io
    # Set testing versions to PR
    - for repo in `integration/extra/release_tool.py -l docker`; do
        integration/extra/release_tool.py --set-version-of $repo --version pr;
      done
    # mender-artifact
    - mkdir -p integration/backend-tests/downloaded-tools
    - mv stage-artifacts/mender-artifact-linux integration/backend-tests/downloaded-tools/mender-artifact
    # copy for pre 2.4.x releases
    - cp integration/backend-tests/downloaded-tools/mender-artifact integration/backend-tests/mender-artifact
    # sysstat monitoring suite for Alpine Linux
    # collect cpu, load avg, memory and io usage every 2 secs forever
    # use 'sar' from sysstat to render the result file manually
    - ln -s /var/log/sa/ /var/log/sysstat
    - sar -P ALL 2 -o /var/log/sysstat/sysstat.log -uqrbS >/dev/null 2>&1 &
  script:
    # Traps only work if executed in a sub shell.
    - "("

    - function handle_exit() {
      ${CI_PROJECT_DIR}/scripts/maybe-wait-in-stage.sh WAIT_IN_STAGE_TEST ${CI_PROJECT_DIR}/WAIT_IN_STAGE_TEST;
      };
      trap handle_exit EXIT

    - INTEGRATION_TEST_SUITE=$(integration/extra/release_tool.py --select-test-suite || echo "all")

    - >
      if [ "$INTEGRATION_TEST_SUITE" = "$TEST_SUITE" ] || [ "$INTEGRATION_TEST_SUITE" = "all" ]; then
        # Post job status
        ${CI_PROJECT_DIR}/scripts/github_pull_request_status pending "Gitlab ${CI_JOB_NAME} started" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

        echo Running backend-tests suite $INTEGRATION_TEST_SUITE
        cd integration/backend-tests/

        # From 2.4.x on, the script would download the requirements by default
        if ./run --help | grep -e --no-download; then
          RUN_ARGS="--no-download";
        fi

        # for pre 2.2.x releases, ignore test suite selection and just run open tests
        if ./run --help | grep -e --suite; then
          ./run --suite $INTEGRATION_TEST_SUITE $RUN_ARGS;
        else
          PYTEST_ARGS="-k 'not Multitenant'" ./run;
        fi

        # Always keep this at the end of the script stage
        echo "success" > /JOB_RESULT.txt
      else
        echo "skipped" > /JOB_RESULT.txt
      fi

    - ")"

  after_script:
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - >
      if [ "$(cat /JOB_RESULT.txt)" != "skipped" ]; then
        if [ "$(cat /JOB_RESULT.txt)" != "success" ]; then ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"; fi

        find ${CI_PROJECT_DIR}/../integration/backend-tests -mindepth 1 -maxdepth 1 -name 'acceptance.*' -exec cp "{}" . \;
        ls ${CI_PROJECT_DIR}/../integration/backend-tests/results_*xml | xargs -n 1 -i cp {} .
        ls ${CI_PROJECT_DIR}/../integration/backend-tests/report_*html | xargs -n 1 -i cp {} .

        if [ "$NIGHTLY_BUILD" = "true" ]; then
          ${CI_PROJECT_DIR}/scripts/mantra_post_test_results 7 nightly-$(date +%Y-%m-%d) results_backend_integration_open.xml
          ${CI_PROJECT_DIR}/scripts/mantra_post_test_results 8 nightly-$(date +%Y-%m-%d) results_backend_integration_enterprise.xml
        fi

        cp /var/log/sysstat/sysstat.log .
        sadf sysstat.log -g -- -qurbS > sysstat.svg

        # Post job status
        ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"
      fi

  artifacts:
    expire_in: 2w
    when: always
    paths:
      - acceptance.*
      - results_backend_integration_*.xml
      - report_backend_integration_*.html
      - sysstat.log
      - sysstat.svg
    reports:
      junit: results_backend_integration_*.xml

test_backend_integration_open_source:
  extends: test_backend_integration_enterprise
  variables:
    TEST_SUITE: "open"

test_full_integration_enterprise:
  only:
    variables:
      - $RUN_INTEGRATION_TESTS == "true"
  stage: test
  # Integration tests depends on running ssh to containers, we're forced to
  # run dockerd on the same host.
  image: docker:19.03-dind
  variables:
    DOCKER_CLIENT_TIMEOUT: 300
    COMPOSE_HTTP_TIMEOUT: 300
    TEST_SUITE: "enterprise"
  tags:
    - mender-qa-slave-highmem
  needs:
    - init_workspace
    - build_servers
    - build_client
    - build_mender-artifact
  before_script:
    # Default value, will later be overwritten if successful
    - echo "failure" > /JOB_RESULT.txt
    - unset DOCKER_HOST
    - unset DOCKER_TLS_VERIFY
    - unset DOCKER_CERT_PATH

    # Restore workspace from init stage
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - mv workspace.tar.gz build_revisions.env stage-artifacts /tmp
    - rm -rf ${WORKSPACE}
    - mkdir -p ${WORKSPACE}
    - cd ${WORKSPACE}
    - tar -xf /tmp/workspace.tar.gz
    - mv /tmp/build_revisions.env /tmp/stage-artifacts .

    # for Post job status
    - apk --update add curl jq sysstat docker-compose hdparm

    # Start dockerd in the background
    - /usr/local/bin/dockerd &
    # Wait for dockerd to start
    - |-
      MAX_WAIT=30
      while [ ! -e "/var/run/docker.sock" ] && [ $MAX_WAIT -gt 0 ]; do
        MAX_WAIT=$(($MAX_WAIT - 1))
        sleep 1
      done
    - docker version # Verify that the docker server is up and running

    # Output storage io stats
    - df -h . | tail -1 | awk '{system("hdparm -tT "$1);}'
    # Get and install the integration test requirements
    - apk add $(cat ${WORKSPACE}/integration/tests/requirements/apk-requirements.txt)
    - pip install  -r ${WORKSPACE}/integration/tests/requirements/python-requirements.txt
    - pip3 install -r ${WORKSPACE}/integration/tests/requirements/python-requirements.txt

    # Load all docker images
    - for repo in `integration/extra/release_tool.py -l docker`; do
        docker load -i stage-artifacts/${repo}.tar;
      done
    # Login for private repos
    - docker login -u menderbuildsystem -p ${DOCKER_HUB_PASSWORD}
    - docker login -u ntadm_menderci -p ${REGISTRY_MENDER_IO_PASSWORD} registry.mender.io
    # Set testing versions to PR
    - for repo in `integration/extra/release_tool.py -l docker`; do
        integration/extra/release_tool.py --set-version-of $repo --version pr;
      done
    # Other dependencies
    - install stage-artifacts/mender-artifact-linux /usr/local/bin/mender-artifact
    - make -C ${WORKSPACE}/go/src/github.com/mendersoftware/mender install-modules-gen
    # sysstat monitoring suite for Alpine Linux
    # collect cpu, load avg, memory and io usage every 2 secs forever
    # use 'sar' from sysstat to render the result file manually
    - ln -s /var/log/sa/ /var/log/sysstat
    - sar -P ALL 2 -o /var/log/sysstat/sysstat.log -uqrbS >/dev/null 2>&1 &
  script:
    # Traps only work if executed in a sub shell.
    - "("

    - function handle_exit() {
      ${CI_PROJECT_DIR}/scripts/maybe-wait-in-stage.sh WAIT_IN_STAGE_TEST ${CI_PROJECT_DIR}/WAIT_IN_STAGE_TEST;
      };
      trap handle_exit EXIT

    - export INTEGRATION_TEST_SUITE=$(integration/extra/release_tool.py --select-test-suite || echo "all")
    - >
      if [ "$INTEGRATION_TEST_SUITE" = "$TEST_SUITE" ] || [ "$INTEGRATION_TEST_SUITE" = "all" ]; then
        # Post job status
        ${CI_PROJECT_DIR}/scripts/github_pull_request_status pending "Gitlab ${CI_JOB_NAME} started" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

        echo Running integration tests suite $INTEGRATION_TEST_SUITE
        # only do automatic test suite selection if the user wasn't specific
        # run.sh will pick up the SPECIFIC_INTEGRATION_TEST var
        if [ -z "$SPECIFIC_INTEGRATION_TEST" ]; then
          case $INTEGRATION_TEST_SUITE in
            "enterprise")
              export SPECIFIC_INTEGRATION_TEST="Enterprise";;
            "open")
              export SPECIFIC_INTEGRATION_TEST="not Enterprise";;
          esac
        fi
        source ${CI_PROJECT_DIR}/build_revisions.env
        cd integration/tests
        ./run.sh --no-download --machine-name qemux86-64

        # Always keep this at the end of the script stage
        echo "success" > /JOB_RESULT.txt
      else
        echo "skipped" > /JOB_RESULT.txt
      fi

    - ")"

  after_script:
    - unset DOCKER_HOST
    - unset DOCKER_TLS_VERIFY
    - unset DOCKER_CERT_PATH

    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - >
      if [ "$(cat /JOB_RESULT.txt)" != "skipped" ]; then
        if [ "$(cat /JOB_RESULT.txt)" != "success" ]; then ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"; fi

        cp -r ${CI_PROJECT_DIR}/../integration/tests/mender_test_logs .
        cp ${CI_PROJECT_DIR}/../integration/tests/results.xml results_full_integration.xml
        cp ${CI_PROJECT_DIR}/../integration/tests/report.html report_full_integration.html

        if [ "$NIGHTLY_BUILD" = "true" ]; then
          ${CI_PROJECT_DIR}/scripts/mantra_post_test_results 9 nightly-$(date +%Y-%m-%d) results_full_integration.xml
        fi

        cp /var/log/sysstat/sysstat.log .
        sadf sysstat.log -g -- -qurbS > sysstat.svg

        # Post job status
        ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"
      fi

  artifacts:
    expire_in: 2w
    when: always
    paths:
      - mender_test_logs
      - results_full_integration.xml
      - report_full_integration.html
      - sysstat.log
      - sysstat.svg
    reports:
      junit: results_full_integration.xml

test_full_integration_open_source:
  extends: test_full_integration_enterprise
  variables:
    TEST_SUITE: "open"

# Publish acceptance test coverage into coveralls when either running tests for a
# mender PR (MENDER_REV ~= /pull/XXX/head/) or new merge into mender/master that requires
# Docker images publishing (PUBLISH_DOCKER_CLIENT_IMAGES == "true")
.template_publish_acceptance_coverage:
  only:
    variables:
      - $PUBLISH_DOCKER_CLIENT_IMAGES == "true"
      - $MENDER_REV =~ /pull\/.*\/head/
  stage: publish
  needs:
    - init_workspace
  image: golang:1.15-alpine3.12
  before_script:
    - apk --update add git
    # Run go get out of the repo to not modify go.mod
    - cd / && go get github.com/mattn/goveralls && cd -
    # Coveralls env variables:
    #  According to https://docs.coveralls.io/supported-ci-services
    #  we should set CI_NAME, CI_BUILD_NUMBER, etc. But according
    #  to goveralls source code (https://github.com/mattn/goveralls)
    #  many of these are not supported. Set CI_BRANCH, CI_PR_NUMBER,
    #  and pass few others as command line arguments.
    #  See also https://docs.coveralls.io/api-reference
    - export CI_BRANCH=${CI_COMMIT_BRANCH}
    - export CI_PR_NUMBER=${CI_COMMIT_BRANCH#pr_}
    # Get mender source
    - tar xf ${CI_PROJECT_DIR}/workspace.tar.gz ./go/src/github.com/mendersoftware/mender
    - mv go/src/github.com/mendersoftware/mender ${CI_PROJECT_DIR}/mender
    - cd ${CI_PROJECT_DIR}/mender
  script:
    - goveralls
      -repotoken ${MENDER_COVERALLS_TOKEN}
      -service gitlab-ci
      -jobid $(git rev-parse HEAD)
      -covermode set
      -flagname acceptance-${JOB_BASE_NAME}
      -parallel
      -coverprofile $(find ${CI_PROJECT_DIR}/acceptance-tests-coverage -name 'coverage*.out' | tr '\n' ',' | sed 's/,$//')

coveralls:finish-build:
  stage: .post
  # See https://docs.coveralls.io/parallel-build-webhook
  variables:
    COVERALLS_WEBHOOK_URL: "https://coveralls.io/webhook"
  image: appropriate/curl
  dependencies:
    - init_workspace
  before_script:
    - apk --update add git
    # Get mender source
    - tar xf ${CI_PROJECT_DIR}/workspace.tar.gz ./go/src/github.com/mendersoftware/mender
    - mv go/src/github.com/mendersoftware/mender ${CI_PROJECT_DIR}/mender
    - cd ${CI_PROJECT_DIR}/mender
  script:
    - 'curl -k ${COVERALLS_WEBHOOK_URL}?repo_token=${MENDER_COVERALLS_TOKEN} -d "payload[build_num]=$(git rev-parse HEAD)&payload[status]=done"'

publish_accep_qemux86_64_uefi_grub:
  extends: .template_publish_acceptance_coverage
  except:
    variables:
      - $TEST_QEMUX86_64_UEFI_GRUB != "true"
  needs:
    - init_workspace
    - test_accep_qemux86_64_uefi_grub
  variables:
    JOB_BASE_NAME: qemux86_64_uefi_grub

publish_accep_vexpress_qemu:
  extends: .template_publish_acceptance_coverage
  except:
    variables:
      - $TEST_VEXPRESS_QEMU != "true"
  needs:
    - init_workspace
    - test_accep_vexpress_qemu
  variables:
    JOB_BASE_NAME: vexpress_qemu

publish_accep_qemux86_64_bios_grub:
  extends: .template_publish_acceptance_coverage
  except:
    variables:
      - $TEST_QEMUX86_64_BIOS_GRUB != "true"
  needs:
    - init_workspace
    - test_accep_qemux86_64_bios_grub
  variables:
    JOB_BASE_NAME: qemux86_64_bios_grub

publish_accep_qemux86_64_bios_grub_gpt:
  extends: .template_publish_acceptance_coverage
  except:
    variables:
      - $TEST_QEMUX86_64_BIOS_GRUB_GPT != "true"
  needs:
    - init_workspace
    - test_accep_qemux86_64_bios_grub_gpt
  variables:
    JOB_BASE_NAME: qemux86_64_bios_grub_gpt

publish_accep_vexpress_qemu_uboot_uefi_grub:
  extends: .template_publish_acceptance_coverage
  except:
    variables:
      - $TEST_VEXPRESS_QEMU_UBOOT_UEFI_GRUB != "true"
  needs:
    - init_workspace
    - test_accep_vexpress_qemu_uboot_uefi_grub
  variables:
    JOB_BASE_NAME: vexpress_qemu_uboot_uefi_grub

publish_accep_vexpress_qemu_flash:
  extends: .template_publish_acceptance_coverage
  except:
    variables:
      - $TEST_VEXPRESS_QEMU_FLASH != "true"
  needs:
    - init_workspace
    - test_accep_vexpress_qemu_flash
  variables:
    JOB_BASE_NAME: vexpress_qemu_flash

publish_accep_beagleboneblack:
  extends: .template_publish_acceptance_coverage
  except:
    variables:
      - $TEST_BEAGLEBONEBLACK != "true"
  needs:
    - init_workspace
    - test_accep_beagleboneblack
  variables:
    JOB_BASE_NAME: beagleboneblack

publish_accep_raspberrypi3:
  extends: .template_publish_acceptance_coverage
  except:
    variables:
      - $TEST_RASPBERRYPI3 != "true"
  needs:
    - init_workspace
    - test_accep_raspberrypi3
  variables:
    JOB_BASE_NAME: raspberrypi3

publish_accep_raspberrypi4:
  extends: .template_publish_acceptance_coverage
  except:
    variables:
      - $TEST_RASPBERRYPI4 != "true"
  needs:
    - init_workspace
    - test_accep_raspberrypi4
  variables:
    JOB_BASE_NAME: raspberrypi4

# This job allows mender repo to publish the related Docker client images on
# merges to master or release branches.
# Do not confuse with release_docker_images which publishes all images
# (including client ones) used during releases.
publish_docker_client_images:
  only:
    variables:
      - $PUBLISH_DOCKER_CLIENT_IMAGES == "true"
  stage: release
  image: docker
  services:
    - docker:19.03-dind
  needs:
    - init_workspace
    - build_servers
    - build_client
  before_script:
    # Check correct dind setup
    - docker version
    # Install dependencies
    - apk --update add git python3 py3-pip
    - pip3 install --upgrade pyyaml
    # Restore workspace from init stage
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - mv workspace.tar.gz build_revisions.env stage-artifacts /tmp
    - rm -rf ${WORKSPACE}
    - mkdir -p ${WORKSPACE}
    - cd ${WORKSPACE}
    - tar -xf /tmp/workspace.tar.gz
    - mv /tmp/build_revisions.env /tmp/stage-artifacts .
    # Login for private repos
    - docker login -u menderbuildsystem -p ${DOCKER_HUB_PASSWORD}
  script:
    # for pre 2.4.x releases, omit --version-type
    - if $WORKSPACE/integration/extra/release_tool.py --help | grep -e --version-type; then
    -   VERSION_TYPE_PARAMS="--version-type docker"
    - fi
    # Load, tag and push mender-client-docker, mender-client-qemu, mender-client-qemu-rofs
    - for image in $($WORKSPACE/integration/extra/release_tool.py --list docker | grep mender-client); do
        version=$($WORKSPACE/integration/extra/release_tool.py --version-of $image $VERSION_TYPE_PARAMS --in-integration-version HEAD);
        docker_url=$($WORKSPACE/integration/extra/release_tool.py --map-name docker $image docker_url);
        docker load -i stage-artifacts/${image}.tar;
        docker tag $docker_url:pr $docker_url:${version};
        docker push $docker_url:${version};
      done


.template_release_docker_images:
  only:
    variables:
      - ($BUILD_SERVERS == "true" && $BUILD_CLIENT == "true") || $RUN_INTEGRATION_TESTS == "true"
  stage: release
  image: docker:19.03
  services:
    - docker:19.03-dind
  needs:
    - init_workspace
    - build_servers
    - build_client
  before_script:
    # Check correct dind setup
    - docker version
    # Install dependencies
    - apk --update add git python3 py3-pip
    - pip3 install --upgrade pyyaml
    # Restore workspace from init stage
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - mv workspace.tar.gz build_revisions.env stage-artifacts /tmp
    - rm -rf ${WORKSPACE}
    - mkdir -p ${WORKSPACE}
    - cd ${WORKSPACE}
    - tar -xf /tmp/workspace.tar.gz
    - mv /tmp/build_revisions.env /tmp/stage-artifacts .
    # Login for private repos
    - docker login -u menderbuildsystem -p ${DOCKER_HUB_PASSWORD}
    - docker login -u ntadm_menderci -p ${REGISTRY_MENDER_IO_PASSWORD} registry.mender.io
  script:
    # for pre 2.4.x releases, omit --version-type
    - if $WORKSPACE/integration/extra/release_tool.py --help | grep -e --version-type; then
    -   VERSION_TYPE_PARAMS="--version-type docker"
    - fi
    # Load, tag and push Docker images
    - for image in $($WORKSPACE/integration/extra/release_tool.py --list docker); do
        version=$($WORKSPACE/integration/extra/release_tool.py --version-of $image $VERSION_TYPE_PARAMS --in-integration-version HEAD);
        docker_url=$($WORKSPACE/integration/extra/release_tool.py --map-name docker $image docker_url);
        docker load -i stage-artifacts/${image}.tar;
        docker tag $docker_url:pr $docker_url:${version};
        docker push $docker_url:${version};
      done


release_docker_images:manual:
  when: manual
  extends: .template_release_docker_images

release_docker_images:automatic:
  only:
    variables:
      - $PUBLISH_RELEASE_AUTOMATIC == "true"
  extends: .template_release_docker_images

.template_release_board_artifacts:
  stage: release
  image: debian:buster
  dependencies:
    - init_workspace
    - test_accep_qemux86_64_uefi_grub
    - test_accep_vexpress_qemu
    - test_accep_qemux86_64_bios_grub
    - test_accep_qemux86_64_bios_grub_gpt
    - test_accep_vexpress_qemu_uboot_uefi_grub
    - test_accep_vexpress_qemu_flash
    - test_accep_beagleboneblack
    - test_accep_raspberrypi3
    - test_accep_raspberrypi4
  before_script:
    # Install dependencies
    - apt update && apt install -yyq awscli git python3 python3-pip
    - pip3 install --upgrade pyyaml
    # Restore workspace from init stage
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - mv workspace.tar.gz build_revisions.env stage-artifacts /tmp
    - rm -rf ${WORKSPACE}
    - mkdir -p ${WORKSPACE}
    - cd ${WORKSPACE}
    - tar -xf /tmp/workspace.tar.gz
    - mv /tmp/build_revisions.env /tmp/stage-artifacts .
  script:
    # Publish boards artifacts and sdimg (when hw). Note that vexpress-qemu-flash is ignored
    - client_version=$($WORKSPACE/integration/extra/release_tool.py --version-of mender --in-integration-version HEAD)
    - for board_name in qemux86-64-uefi-grub vexpress-qemu qemux86-64-bios-grub-gpt qemux86-64-bios-grub
      vexpress-qemu-uboot-uefi-grub beagleboneblack raspberrypi3 raspberrypi4; do
        aws s3 cp stage-artifacts/${board_name}_release_1_${client_version}.mender
          s3://mender/${client_version}/${board_name}/${board_name}_release_1_${client_version}.mender;
        aws s3api put-object-acl --acl public-read --bucket mender
          --key ${client_version}/${board_name}/${board_name}_release_1_${client_version}.mender;
        if ! echo $board_name | grep -q qemu; then
          aws s3 cp stage-artifacts/mender-${board_name}_${client_version}.sdimg.gz
            s3://mender/${client_version}/${board_name}/mender-${board_name}_${client_version}.sdimg.gz;
          aws s3api put-object-acl --acl public-read --bucket mender
            --key ${client_version}/${board_name}/mender-${board_name}_${client_version}.sdimg.gz;
        fi;
      done


release_board_artifacts:manual:
  when: manual
  extends: .template_release_board_artifacts

release_board_artifacts:automatic:
  only:
    variables:
      - $PUBLISH_RELEASE_AUTOMATIC == "true"
  extends: .template_release_board_artifacts

build_mender-cli:
  stage: build
  only:
    variables:
      - $BUILD_SERVERS == "true"
      - $RUN_INTEGRATION_TESTS == "true"
  image: golang:1.15-alpine3.12
  needs:
    - init_workspace
  before_script:
    # Default value, will later be overwritten if successful
    - echo "failure" > /JOB_RESULT.txt

    # Restore workspace from init stage
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - mv workspace.tar.gz build_revisions.env /tmp
    - rm -rf ${WORKSPACE}
    - mkdir -p ${WORKSPACE}
    - cd ${WORKSPACE}
    - tar -xf /tmp/workspace.tar.gz
    - mv /tmp/build_revisions.env .
    # Export GOPATH
    - export GOPATH="$WORKSPACE/go"

    - apk --update add jq make curl git

    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status pending "Gitlab ${CI_JOB_NAME} started" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

    # cd into component path
    - cd ${WORKSPACE}/go/src/github.com/mendersoftware/mender-cli
  script:
    - if grep -q build-multiplatform Makefile; then
        make build-multiplatform;
      else
        make build;
      fi
    - mkdir -p $CI_PROJECT_DIR/stage-artifacts
    - cp mender-cli* $CI_PROJECT_DIR/stage-artifacts

    # Always keep this at the end of the script stage
    - echo "success" > /JOB_RESULT.txt

  after_script:
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

  artifacts:
    paths:
      - stage-artifacts/

build_mender-artifact:
  stage: build
  only:
    variables:
      - $BUILD_CLIENT == "true"
      - $RUN_INTEGRATION_TESTS == "true"
  image: docker:19.03
  services:
    - docker:dind
  tags:
    - docker
  needs:
    - init_workspace
  before_script:
    # Default value, will later be overwritten if successful
    - echo "failure" > /JOB_RESULT.txt

    # Check correct dind setup
    - docker version
    # Install dependencies
    - apk --update add bash curl git make jq
    # Restore workspace from init stage
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - mv workspace.tar.gz build_revisions.env /tmp
    - rm -rf ${WORKSPACE}
    - mkdir -p ${WORKSPACE}
    - cd ${WORKSPACE}
    - tar -xf /tmp/workspace.tar.gz
    - mv /tmp/build_revisions.env .

    # Post job status
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status pending "Gitlab ${CI_JOB_NAME} started" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

    # cd into component path
    - cd ${WORKSPACE}/go/src/github.com/mendersoftware/mender-artifact
  script:
    - make build-natives-contained
    - mkdir -p $CI_PROJECT_DIR/stage-artifacts
    - cp mender-artifact-* $CI_PROJECT_DIR/stage-artifacts

    # Always keep this at the end of the script stage
    - echo "success" > /JOB_RESULT.txt

  after_script:
    # Post job status
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - ${CI_PROJECT_DIR}/scripts/github_pull_request_status $(cat /JOB_RESULT.txt) "Gitlab ${CI_JOB_NAME} finished" "${CI_JOB_URL}" "${CI_JOB_NAME}/${INTEGRATION_REV}"

  artifacts:
    expire_in: 2w
    paths:
      - stage-artifacts/

.template_release_binary_tools:
  only:
    variables:
      - ($BUILD_SERVERS == "true" && $BUILD_CLIENT == "true") || $RUN_INTEGRATION_TESTS == "true"
  stage: release
  image: debian:buster
  needs:
    - init_workspace
    - build_mender-cli
    - build_mender-artifact
  before_script:
    # Install dependencies
    - apt update && apt install -yyq awscli git python3 python3-pip
    - pip3 install --upgrade pyyaml
    # Restore workspace from init stage
    - export WORKSPACE=$(realpath ${CI_PROJECT_DIR}/..)
    - mv workspace.tar.gz build_revisions.env stage-artifacts /tmp
    - rm -rf ${WORKSPACE}
    - mkdir -p ${WORKSPACE}
    - cd ${WORKSPACE}
    - tar -xf /tmp/workspace.tar.gz
    - mv /tmp/build_revisions.env /tmp/stage-artifacts .
  script:
    # mender-cli
    - mender_cli_version=$($WORKSPACE/integration/extra/release_tool.py --version-of mender-cli --in-integration-version HEAD)
    - echo "=== mender-cli $mender_cli_version ==="
    # We can simplify once mender-cli 1.2.0 is not supported
    - if grep -q build-multiplatform $WORKSPACE/go/src/github.com/mendersoftware/mender-cli/Makefile; then
        echo "Publishing ${mender_cli_version} version for linux to S3";
        aws s3 cp stage-artifacts/mender-cli.linux.amd64
          s3://mender/mender-cli/${mender_cli_version}/linux/mender-cli;
        aws s3api put-object-acl --acl public-read --bucket mender
          --key mender-cli/${mender_cli_version}/linux/mender-cli;
        echo "Publishing ${mender_cli_version} version for darwin to S3";
        aws s3 cp stage-artifacts/mender-cli.darwin.amd64
          s3://mender/mender-cli/${mender_cli_version}/darwin/mender-cli;
        aws s3api put-object-acl --acl public-read --bucket mender
          --key mender-cli/${mender_cli_version}/darwin/mender-cli;
      else
        aws s3 cp stage-artifacts/mender-cli
          s3://mender/mender-cli/${mender_cli_version}/mender-cli;
        aws s3api put-object-acl --acl public-read --bucket mender
          --key mender-cli/${mender_cli_version}/mender-cli;
      fi
    # mender-artifact
    - mender_artifact_version=$($WORKSPACE/integration/extra/release_tool.py --version-of mender-artifact --in-integration-version HEAD)
    - echo "=== mender-artifact $mender_artifact_version ==="
    - for bin in mender-artifact-darwin mender-artifact-linux mender-artifact-windows.exe; do
        platform=${bin#mender-artifact-};
        platform=${platform%.*};
        echo "Publishing ${mender_artifact_version} version for ${platform} to S3";
        aws s3 cp stage-artifacts/${bin}
          s3://mender/mender-artifact/${mender_artifact_version}/${platform}/mender-artifact;
        aws s3api put-object-acl --acl public-read --bucket mender
          --key mender-artifact/${mender_artifact_version}/${platform}/mender-artifact;
      done

release_binary_tools:manual:
  when: manual
  extends: .template_release_binary_tools

release_binary_tools:automatic:
  only:
    variables:
      - $PUBLISH_RELEASE_AUTOMATIC == "true"
  extends: .template_release_binary_tools
